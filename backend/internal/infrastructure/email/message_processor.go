// internal/infrastructure/email/message_processor.go
package email

import (
	"context"
	"fmt"
	"strings"

	"github.com/audetv/urms/internal/core/domain"
	"github.com/audetv/urms/internal/core/ports"
	"github.com/audetv/urms/internal/core/services"
)

// MessageProcessor —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Task Management
type MessageProcessor struct {
	taskService     ports.TaskService
	customerService ports.CustomerService
	emailGateway    ports.EmailGateway
	headerFilter    *HeaderFilter
	searchConfig    ports.EmailSearchConfigProvider // ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π –ø–æ—Ä—Ç
	searchService   *services.EmailSearchService    // ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú —Å–µ—Ä–≤–∏—Å –ø–æ–∏—Å–∫–∞
	logger          ports.Logger
}

// NewMessageProcessor —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞
func NewMessageProcessor(
	taskService ports.TaskService,
	customerService ports.CustomerService,
	emailGateway ports.EmailGateway,
	searchConfig ports.EmailSearchConfigProvider, // ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú dependency
	logger ports.Logger,
) ports.MessageProcessor {

	// ‚úÖ –°–û–ó–î–ê–ï–ú —Å–µ—Ä–≤–∏—Å –ø–æ–∏—Å–∫–∞
	searchService := services.NewEmailSearchService(searchConfig, logger)

	return &MessageProcessor{
		taskService:     taskService,
		customerService: customerService,
		emailGateway:    emailGateway,
		headerFilter:    NewHeaderFilter(logger),
		searchConfig:    searchConfig,  // ‚úÖ –°–û–•–†–ê–ù–Ø–ï–ú
		searchService:   searchService, // ‚úÖ –°–û–•–†–ê–ù–Ø–ï–ú
		logger:          logger,
	}
}

// ProcessIncomingEmail –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Ö–æ–¥—è—â–∏–µ email —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Task Management
func (p *MessageProcessor) ProcessIncomingEmail(ctx context.Context, email domain.EmailMessage) error {
	p.logger.Info(ctx, "Processing incoming email with ENHANCED THREAD SEARCH",
		"message_id", email.MessageID,
		"from", email.From,
		"subject", email.Subject,
		"operation", "enhanced_thread_search_process")

	// 1. –í–∞–ª–∏–¥–∞—Ü–∏—è email
	if err := p.validateIncomingEmail(ctx, email); err != nil {
		p.logger.Error(ctx, "Incoming email validation failed",
			"message_id", email.MessageID,
			"error", err.Error())
		return fmt.Errorf("email validation failed: %w", err)
	}

	// 2. –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –ó–ê–ì–û–õ–û–í–ö–û–í
	emailHeaders, err := p.headerFilter.FilterEssentialHeaders(ctx, &email)
	if err != nil {
		p.logger.Error(ctx, "Failed to filter essential headers",
			"message_id", email.MessageID,
			"error", err.Error())
		return fmt.Errorf("headers filtering failed: %w", err)
	}

	// 3. –ü–æ–∏—Å–∫ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞
	customer, err := p.findOrCreateCustomer(ctx, email)
	if err != nil {
		p.logger.Error(ctx, "Failed to find or create customer",
			"message_id", email.MessageID,
			"from", email.From,
			"error", err.Error())
		return fmt.Errorf("customer management failed: %w", err)
	}

	// 4. ‚úÖ –£–õ–£–ß–®–ï–ù–ù–´–ô –ü–û–ò–°–ö –°–£–©–ï–°–¢–í–£–Æ–©–ï–ô –ó–ê–î–ê–ß–ò
	existingTask, err := p.findExistingTaskByThreadEnhanced(ctx, email, emailHeaders)
	if err != nil {
		p.logger.Error(ctx, "Failed to search for existing task with enhanced search",
			"message_id", email.MessageID,
			"error", err.Error())
		// –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
	}

	var task *domain.Task
	if existingTask != nil {
		// 5a. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–¥–∞—á—É
		task, err = p.addMessageToExistingTask(ctx, existingTask, email, customer.ID, emailHeaders)
		if err != nil {
			p.logger.Error(ctx, "Failed to add message to existing task",
				"task_id", existingTask.ID,
				"message_id", email.MessageID,
				"error", err.Error())
			return fmt.Errorf("failed to update existing task: %w", err)
		}
		p.logger.Info(ctx, "Message added to existing task found via ENHANCED search",
			"task_id", existingTask.ID,
			"message_id", email.MessageID)
	} else {
		// 5b. –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏
		task, err = p.createNewTaskFromEmail(ctx, email, customer.ID, emailHeaders)
		if err != nil {
			p.logger.Error(ctx, "Failed to create new task from email",
				"message_id", email.MessageID,
				"error", err.Error())
			return fmt.Errorf("failed to create task: %w", err)
		}
		p.logger.Info(ctx, "New task created from email - no existing thread found",
			"task_id", task.ID,
			"message_id", email.MessageID)
	}

	// 6. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ
	if task.AssigneeID == "" {
		task, err = p.autoAssignTask(ctx, task)
		if err != nil {
			p.logger.Warn(ctx, "Auto-assignment failed, task remains unassigned",
				"task_id", task.ID,
				"error", err.Error())
		} else {
			p.logger.Info(ctx, "Task auto-assigned",
				"task_id", task.ID,
				"assignee_id", task.AssigneeID)
		}
	}

	p.logger.Info(ctx, "Incoming email processed successfully with ENHANCED THREAD SEARCH",
		"message_id", email.MessageID,
		"task_id", task.ID,
		"customer_id", customer.ID,
		"headers_optimized", true,
		"enhanced_search_used", true,
		"operation", "enhanced_thread_search_complete")

	return nil
}

// findExistingTaskByThreadEnhanced - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ï–ô
func (p *MessageProcessor) findExistingTaskByThreadEnhanced(ctx context.Context, email domain.EmailMessage, headers *domain.EmailHeaders) (*domain.Task, error) {
	if headers == nil {
		p.logger.Debug(ctx, "No headers provided for enhanced thread search")
		return nil, nil
	}

	// ‚úÖ –°–¢–†–ê–¢–ï–ì–ò–Ø 1: –ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –ø–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º threading –¥–∞–Ω–Ω—ã–º
	existingTask, err := p.findExistingTaskByThread(ctx, headers)
	if err != nil {
		p.logger.Warn(ctx, "Standard thread search failed, trying enhanced search",
			"message_id", headers.MessageID,
			"error", err.Error())
	} else if existingTask != nil {
		p.logger.Info(ctx, "‚úÖ Found existing task via standard search",
			"message_id", headers.MessageID,
			"task_id", existingTask.ID)
		return existingTask, nil
	}

	// ‚úÖ –°–¢–†–ê–¢–ï–ì–ò–Ø 2: Enhanced IMAP search —Å –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ï–ô
	p.logger.Info(ctx, "üöÄ Starting ENHANCED IMAP thread search with CONFIGURABLE parameters",
		"message_id", headers.MessageID,
		"subject", headers.Subject,
		"in_reply_to", headers.InReplyTo,
		"references_count", len(headers.References))

	// ‚úÖ –ü–û–õ–£–ß–ê–ï–ú –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Æ –î–õ–Ø –õ–û–ì–ò–†–û–í–ê–ù–ò–Ø
	searchConfig, err := p.searchService.GetThreadSearchConfig(ctx)
	if err != nil {
		p.logger.Warn(ctx, "Failed to get search config, using enhanced search without config",
			"message_id", headers.MessageID,
			"error", err.Error())
	} else {
		p.logger.Info(ctx, "Using CONFIGURABLE search parameters",
			"default_days", searchConfig.DefaultDaysBack(),
			"extended_days", searchConfig.ExtendedDaysBack(),
			"max_days", searchConfig.MaxDaysBack(),
			"search_strategy", "extended_time_range+combined_criteria")
	}

	// –°–æ–∑–¥–∞–µ–º –∫—Ä–∏—Ç–µ—Ä–∏–∏ –¥–ª—è thread-aware –ø–æ–∏—Å–∫–∞
	threadCriteria := ports.ThreadSearchCriteria{
		MessageID:  headers.MessageID,
		InReplyTo:  headers.InReplyTo,
		References: headers.References,
		Subject:    p.normalizeSubject(headers.Subject),
		Mailbox:    "INBOX",
	}

	// –í—ã–ø–æ–ª–Ω—è–µ–º ENHANCED –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ EmailGateway
	threadMessages, err := p.emailGateway.SearchThreadMessages(ctx, threadCriteria)
	if err != nil {
		p.logger.Warn(ctx, "Enhanced IMAP thread search failed",
			"message_id", headers.MessageID,
			"error", err.Error())
		return nil, nil // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å —Å–æ–∑–¥–∞–Ω–∏–µ–º –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏
	}

	p.logger.Info(ctx, "Enhanced IMAP thread search completed",
		"message_id", headers.MessageID,
		"found_messages", len(threadMessages),
		"search_criteria", fmt.Sprintf("%+v", threadCriteria))

	// –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ü–µ–ø–æ—á–∫–µ, –∏—â–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∑–∞–¥–∞—á—É
	if len(threadMessages) > 0 {
		task := p.findTaskForThreadMessages(ctx, threadMessages)
		if task != nil {
			p.logger.Info(ctx, "‚úÖ SUCCESS: Found existing task via ENHANCED IMAP search",
				"message_id", headers.MessageID,
				"task_id", task.ID,
				"thread_messages_found", len(threadMessages),
				"search_improvement", "configurable_extended_time_range")
			return task, nil
		}

		p.logger.Warn(ctx, "Found thread messages but no existing task - creating new task",
			"message_id", headers.MessageID,
			"thread_messages_count", len(threadMessages),
			"first_thread_message_id", safeGetMessageID(threadMessages))
	}

	p.logger.Info(ctx, "Enhanced thread search completed - creating new task",
		"message_id", headers.MessageID,
		"reason", "no_existing_task_found_with_enhanced_search")

	return nil, nil
}

// ‚úÖ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ô –ú–ï–¢–û–î: findTaskForThreadMessages
func (p *MessageProcessor) findTaskForThreadMessages(ctx context.Context, messages []domain.EmailMessage) *domain.Task {
	// –ò—â–µ–º –∑–∞–¥–∞—á—É –ø–æ Message-ID –ø–µ—Ä–≤–æ–≥–æ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ü–µ–ø–æ—á–∫–µ
	for _, msg := range messages {
		if msg.MessageID == "" {
			continue
		}

		searchMeta := map[string]interface{}{
			"message_id": msg.MessageID,
		}

		tasks, err := p.taskService.FindBySourceMeta(ctx, searchMeta)
		if err != nil {
			p.logger.Warn(ctx, "Failed to search task for thread message",
				"message_id", msg.MessageID,
				"error", err.Error())
			continue
		}

		if len(tasks) > 0 {
			return &tasks[0]
		}
	}

	return nil
}

// ProcessOutgoingEmail –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏—Å—Ö–æ–¥—è—â–∏–µ email —Å–æ–æ–±—â–µ–Ω–∏—è
func (p *MessageProcessor) ProcessOutgoingEmail(ctx context.Context, email domain.EmailMessage) error {
	p.logger.Info(ctx, "Processing outgoing email with task integration",
		"message_id", email.MessageID,
		"to", email.To,
		"subject", email.Subject,
		"operation", "advanced_process_outgoing_email")

	// 1. –í–∞–ª–∏–¥–∞—Ü–∏—è –∏—Å—Ö–æ–¥—è—â–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
	if err := p.validateOutgoingEmail(ctx, email); err != nil {
		p.logger.Error(ctx, "Outgoing email validation failed",
			"message_id", email.MessageID,
			"error", err.Error())
		return fmt.Errorf("outgoing email validation failed: %w", err)
	}

	// 2. –ï—Å–ª–∏ email —Å–≤—è–∑–∞–Ω —Å –∑–∞–¥–∞—á–µ–π, –¥–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
	if email.RelatedTicketID != nil {
		task, err := p.taskService.GetTask(ctx, *email.RelatedTicketID)
		if err != nil {
			p.logger.Error(ctx, "Failed to get related task for outgoing email",
				"task_id", *email.RelatedTicketID,
				"message_id", email.MessageID,
				"error", err.Error())
		} else {
			// –î–æ–±–∞–≤–ª—è–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∑–∞–¥–∞—á—É
			messageReq := ports.AddMessageRequest{
				AuthorID:  "system", // TODO: –ó–∞–º–µ–Ω–∏—Ç—å –Ω–∞ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
				Content:   fmt.Sprintf("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –ø–æ email: %s", email.Subject),
				Type:      domain.MessageTypeInternal,
				IsPrivate: true,
			}
			_, err = p.taskService.AddMessage(ctx, task.ID, messageReq)
			if err != nil {
				p.logger.Warn(ctx, "Failed to add outgoing message to task",
					"task_id", task.ID,
					"message_id", email.MessageID,
					"error", err.Error())
			} else {
				p.logger.Info(ctx, "Outgoing email logged in task",
					"task_id", task.ID,
					"message_id", email.MessageID)
			}
		}
	}

	p.logger.Info(ctx, "Outgoing email processed successfully",
		"message_id", email.MessageID,
		"operation", "outgoing_email_processed")

	return nil
}

// findOrCreateCustomer –Ω–∞—Ö–æ–¥–∏—Ç –∏–ª–∏ —Å–æ–∑–¥–∞–µ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –ø–æ email
func (p *MessageProcessor) findOrCreateCustomer(ctx context.Context, email domain.EmailMessage) (*domain.Customer, error) {
	customerName := p.extractNameFromEmail(string(email.From))

	customer, err := p.customerService.FindOrCreateByEmail(ctx, string(email.From), customerName)
	if err != nil {
		return nil, fmt.Errorf("failed to find or create customer: %w", err)
	}

	return customer, nil
}

// findExistingTaskByThread –∏—â–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–¥–∞—á—É –ø–æ Thread-ID —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º EmailHeaders
func (p *MessageProcessor) findExistingTaskByThread(ctx context.Context, headers *domain.EmailHeaders) (*domain.Task, error) {
	if headers == nil {
		p.logger.Debug(ctx, "No headers provided for thread search")
		return nil, nil
	}

	// –°–æ–∑–¥–∞–µ–º –∫—Ä–∏—Ç–µ—Ä–∏–∏ –ø–æ–∏—Å–∫–∞ –ø–æ Thread-ID –∏–∑ EmailHeaders
	searchMeta := make(map[string]interface{})

	if headers.MessageID != "" {
		searchMeta["message_id"] = headers.MessageID
	}
	if headers.InReplyTo != "" {
		searchMeta["in_reply_to"] = headers.InReplyTo
	}
	if len(headers.References) > 0 {
		searchMeta["references"] = headers.References
	}

	// ‚úÖ –õ–û–ì–ò–†–£–ï–ú –ö–†–ò–¢–ï–†–ò–ò –ü–û–ò–°–ö–ê –° –ù–û–í–û–ô –ê–†–•–ò–¢–ï–ö–¢–£–†–û–ô
	p.logger.Debug(ctx, "Email threading search with OPTIMIZED headers",
		"message_id", headers.MessageID,
		"in_reply_to", headers.InReplyTo,
		"references_count", len(headers.References),
		"search_meta", searchMeta)

	// –ï—Å–ª–∏ –Ω–µ—Ç –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
	if len(searchMeta) == 0 {
		p.logger.Debug(ctx, "No thread criteria found for email",
			"message_id", headers.MessageID)
		return nil, nil
	}

	// –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–¥–∞—á–∏ –ø–æ Thread-ID
	tasks, err := p.taskService.FindBySourceMeta(ctx, searchMeta)
	if err != nil {
		p.logger.Warn(ctx, "Failed to search tasks by source meta",
			"message_id", headers.MessageID,
			"error", err.Error())
		return nil, err
	}

	// ‚úÖ –õ–û–ì–ò–†–£–ï–ú –†–ï–ó–£–õ–¨–¢–ê–¢–´ –ü–û–ò–°–ö–ê –° –ù–û–í–û–ô –ê–†–•–ò–¢–ï–ö–¢–£–†–û–ô
	p.logger.Debug(ctx, "Email threading search results with OPTIMIZED headers",
		"message_id", headers.MessageID,
		"tasks_found", len(tasks),
		"search_criteria", searchMeta)

	// –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∞–º—É—é —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—É—é –∑–∞–¥–∞—á—É (–ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é)
	if len(tasks) > 0 {
		p.logger.Info(ctx, "Found existing task for email thread with OPTIMIZED headers",
			"message_id", headers.MessageID,
			"task_id", tasks[0].ID,
			"matches_count", len(tasks),
			"search_criteria", searchMeta)
		return &tasks[0], nil
	}

	p.logger.Debug(ctx, "No existing task found for email thread with OPTIMIZED headers",
		"message_id", headers.MessageID,
		"in_reply_to", headers.InReplyTo,
		"references_count", len(headers.References))
	return nil, nil
}

// createNewTaskFromEmail —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É –∏–∑ email —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º EmailHeaders
func (p *MessageProcessor) createNewTaskFromEmail(ctx context.Context, email domain.EmailMessage, customerID string, headers *domain.EmailHeaders) (*domain.Task, error) {
	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
	priority := p.determinePriority(ctx, email)

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é
	category := p.determineCategory(ctx, email)

	// ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –ù–û–í–£–Æ –ê–†–•–ò–¢–ï–ö–¢–£–†–£ –î–õ–Ø SOURCE META
	sourceMeta := p.buildSourceMeta(headers, email)

	req := ports.CreateSupportTaskRequest{
		Subject:     p.normalizeSubject(headers.Subject),
		Description: p.buildTaskDescription(email, headers),
		CustomerID:  customerID,
		ReporterID:  "system",
		Source:      domain.SourceEmail,
		SourceMeta:  sourceMeta,
		Priority:    priority,
		Category:    category,
		Tags:        p.extractTags(ctx, email),
	}

	// ‚úÖ –õ–û–ì–ò–†–£–ï–ú –°–û–ó–î–ê–ù–ò–ï –ó–ê–î–ê–ß–ò –° OPTIMIZED SOURCE META
	p.logger.Info(ctx, "Creating new task with OPTIMIZED source meta",
		"message_id", headers.MessageID,
		"in_reply_to", headers.InReplyTo,
		"references_count", len(headers.References),
		"source_meta_size", fmt.Sprintf("%d keys", len(sourceMeta)),
		"headers_optimized", true)

	task, err := p.taskService.CreateSupportTask(ctx, req)
	if err != nil {
		return nil, fmt.Errorf("failed to create support task: %w", err)
	}

	return task, nil
}

// addMessageToExistingTask –¥–æ–±–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–¥–∞—á—É
func (p *MessageProcessor) addMessageToExistingTask(ctx context.Context, task *domain.Task, email domain.EmailMessage, customerID string, headers *domain.EmailHeaders) (*domain.Task, error) {
	messageReq := ports.AddMessageRequest{
		AuthorID:  customerID,
		Content:   p.buildMessageContent(email),
		Type:      domain.MessageTypeCustomer,
		IsPrivate: false,
	}

	updatedTask, err := p.taskService.AddMessage(ctx, task.ID, messageReq)
	if err != nil {
		return nil, fmt.Errorf("failed to add message to task: %w", err)
	}

	return updatedTask, nil
}

// autoAssignTask –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–∑–Ω–∞—á–∞–µ—Ç –∑–∞–¥–∞—á—É
func (p *MessageProcessor) autoAssignTask(ctx context.Context, task *domain.Task) (*domain.Task, error) {
	// –ë–∞–∑–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è - –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
	// TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—É—é –ª–æ–≥–∏–∫—É –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è

	// –í—Ä–µ–º–µ–Ω–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–¥–∞—á—É –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
	// –†–µ–∞–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –±—É–¥–µ—Ç –≤ Phase 4 —Å AI
	return task, nil
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã

func (p *MessageProcessor) validateIncomingEmail(ctx context.Context, email domain.EmailMessage) error {
	if email.MessageID == "" {
		return fmt.Errorf("message ID is required")
	}
	if email.From == "" {
		return fmt.Errorf("sender address is required")
	}
	if len(email.To) == 0 && len(email.CC) == 0 {
		return fmt.Errorf("no recipients found")
	}
	return nil
}

func (p *MessageProcessor) validateOutgoingEmail(ctx context.Context, email domain.EmailMessage) error {
	if email.MessageID == "" {
		return fmt.Errorf("message ID is required")
	}
	if len(email.To) == 0 {
		return fmt.Errorf("at least one recipient is required")
	}
	if email.Subject == "" {
		return fmt.Errorf("subject is required for outgoing emails")
	}
	return nil
}

func (p *MessageProcessor) extractNameFromEmail(email string) string {
	parts := strings.Split(email, "@")
	if len(parts) > 0 {
		namePart := strings.ReplaceAll(parts[0], ".", " ")
		return strings.Title(namePart) // –ü—Ä–æ—Å—Ç–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞
	}
	return "Customer"
}

func (p *MessageProcessor) normalizeSubject(subject string) string {
	// –£–±–∏—Ä–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å—ã —Ç–∏–ø–∞ "Re:", "Fwd:" –∏ —Ç.–¥.
	prefixes := []string{"Re:", "Fwd:", "FW:", "RE:", "–û—Ç–≤–µ—Ç:", "FWD:"}
	result := subject

	for _, prefix := range prefixes {
		if strings.HasPrefix(strings.ToUpper(result), strings.ToUpper(prefix)) {
			result = strings.TrimSpace(result[len(prefix):])
		}
	}

	if result == "" {
		return "–ë–µ–∑ —Ç–µ–º—ã"
	}

	return result
}

func (p *MessageProcessor) determinePriority(ctx context.Context, email domain.EmailMessage) domain.Priority {
	// –ë–∞–∑–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞
	content := strings.ToLower(email.Subject + " " + email.BodyText)

	urgencyKeywords := []string{"—Å—Ä–æ—á–Ω–æ", "urgent", "critical", "–≤–∞–∂–Ω–æ", "error", "–æ—à–∏–±–∫–∞"}
	for _, keyword := range urgencyKeywords {
		if strings.Contains(content, keyword) {
			return domain.PriorityHigh
		}
	}

	return domain.PriorityMedium
}

func (p *MessageProcessor) determineCategory(ctx context.Context, email domain.EmailMessage) string {
	// –ë–∞–∑–æ–≤–∞—è –ª–æ–≥–∏–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
	content := strings.ToLower(email.Subject + " " + email.BodyText)

	categories := map[string][]string{
		"technical": {"–æ—à–∏–±–∫–∞", "error", "bug", "—Å–ª–æ–º–∞–ª", "–Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç"},
		"billing":   {"–æ–ø–ª–∞—Ç–∞", "payment", "—Å—á–µ—Ç", "invoice", "bill"},
		"general":   {"–≤–æ–ø—Ä–æ—Å", "question", "–ø–æ–º–æ—â—å", "help"},
	}

	for category, keywords := range categories {
		for _, keyword := range keywords {
			if strings.Contains(content, keyword) {
				return category
			}
		}
	}

	return "general"
}

// buildTaskDescription —Å–æ–∑–¥–∞–µ—Ç –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ –∏–∑ email —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º EmailHeaders
func (p *MessageProcessor) buildTaskDescription(email domain.EmailMessage, headers *domain.EmailHeaders) string {
	var description strings.Builder

	description.WriteString("–ó–∞—è–≤–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑ –≤—Ö–æ–¥—è—â–µ–≥–æ email.\n\n")
	description.WriteString("–û—Ç: " + string(headers.From) + "\n")
	description.WriteString("–¢–µ–º–∞: " + headers.Subject + "\n")
	description.WriteString("–î–∞—Ç–∞: " + headers.Date.Format("2006-01-02 15:04:05") + "\n\n")

	// ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –†–ï–ê–õ–¨–ù–û–ï –°–û–î–ï–†–ñ–ê–ù–ò–ï –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –∑–∞–¥–∞—á–∏
	if email.BodyText != "" {
		description.WriteString("–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è:\n")
		// –û–±—Ä–µ–∑–∞–µ–º —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è
		if len(email.BodyText) > 500 {
			description.WriteString(email.BodyText[:500] + "...")
		} else {
			description.WriteString(email.BodyText)
		}
	} else if email.BodyHTML != "" {
		description.WriteString("–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è (HTML):\n")
		description.WriteString("[HTML content - see messages for full text]")
	} else {
		description.WriteString("–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–µ–∫—Å—Ç–∞.")
	}

	return description.String()
}

// buildMessageContent —Å–æ–∑–¥–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ email
func (p *MessageProcessor) buildMessageContent(email domain.EmailMessage) string {
	var content strings.Builder

	// ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –†–ï–ê–õ–¨–ù–û–ï –°–û–î–ï–†–ñ–ê–ù–ò–ï –ü–ò–°–¨–ú–ê –≤–º–µ—Å—Ç–æ –∑–∞–≥–ª—É—à–∫–∏
	if email.BodyText != "" {
		content.WriteString(email.BodyText)
	} else if email.BodyHTML != "" {
		// TODO: –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å HTML –≤ —Ç–µ–∫—Å—Ç
		content.WriteString("[HTML content - needs conversion]")
	} else {
		content.WriteString("[No message content]")
	}

	// –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–ª–æ–∂–µ–Ω–∏—è—Ö
	if len(email.Attachments) > 0 {
		content.WriteString(fmt.Sprintf("\n\nüìé –í–ª–æ–∂–µ–Ω–∏—è: %d —Ñ–∞–π–ª(–æ–≤)", len(email.Attachments)))
		for _, att := range email.Attachments {
			content.WriteString(fmt.Sprintf("\n- %s (%s, %d bytes)",
				att.Name, att.ContentType, att.Size))
		}
	}

	return content.String()
}

// buildSourceMeta - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–û–ù–ù–´–ú–ò –¢–ï–ì–ê–ú–ò
func (p *MessageProcessor) buildSourceMeta(headers *domain.EmailHeaders, email domain.EmailMessage) map[string]interface{} {
	// –ò—Å–ø–æ–ª—å–∑—É–µ–º EmailHeaders value object –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è source_meta
	sourceMeta := headers.ToSourceMeta()

	// –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–ª–æ–∂–µ–Ω–∏—è—Ö
	if len(email.Attachments) > 0 {
		attachments := make([]map[string]interface{}, len(email.Attachments))
		for i, att := range email.Attachments {
			attachments[i] = map[string]interface{}{
				"name":         att.Name,
				"content_type": att.ContentType,
				"size":         att.Size,
			}
		}
		sourceMeta["attachments"] = attachments
	}

	// ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú –ò–ù–§–û–†–ú–ê–¶–ò–Æ –û –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò –ü–û–ò–°–ö–ê
	ctx := context.Background()
	searchConfig, err := p.searchService.GetThreadSearchConfig(ctx)
	if err == nil {
		sourceMeta["search_config"] = map[string]interface{}{
			"default_days_back":  searchConfig.DefaultDaysBack(),
			"extended_days_back": searchConfig.ExtendedDaysBack(),
			"max_days_back":      searchConfig.MaxDaysBack(),
			"config_version":     "phase3c_enhanced",
		}
	}

	// ‚úÖ –õ–û–ì–ò–†–£–ï–ú –†–ï–ó–£–õ–¨–¢–ê–¢ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò –° –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ï–ô
	p.logger.Debug(ctx, "Built OPTIMIZED source meta with CONFIGURABLE search",
		"message_id", headers.MessageID,
		"source_meta_keys", len(sourceMeta),
		"headers_optimized", true,
		"threading_data_preserved", headers.HasThreadingData(),
		"search_config_included", err == nil)

	return sourceMeta
}

// extractTags - –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –° –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–û–ù–ù–´–ú–ò –¢–ï–ì–ê–ú–ò
func (p *MessageProcessor) extractTags(ctx context.Context, email domain.EmailMessage) []string {
	tags := []string{
		"email",
		"auto-created",
		"headers-optimized",
		"phase3c-enhanced", // ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú –¢–ï–ì –ù–û–í–û–ô –í–ï–†–°–ò–ò
	}

	// ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú –¢–ï–ì –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò –ü–û–ò–°–ö–ê
	searchConfig, err := p.searchService.GetThreadSearchConfig(ctx)
	if err == nil {
		tags = append(tags, fmt.Sprintf("search-%ddays", searchConfig.ExtendedDaysBack()))
	}

	// –î–æ–±–∞–≤–ª—è–µ–º —Ç–µ–≥–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
	content := strings.ToLower(email.Subject + " " + email.BodyText)

	if strings.Contains(content, "—Å—Ä–æ—á–Ω–æ") || strings.Contains(content, "urgent") {
		tags = append(tags, "urgent")
	}

	if len(email.Attachments) > 0 {
		tags = append(tags, "has-attachments")
	}

	p.logger.Debug(ctx, "Generated tags for email",
		"message_id", email.MessageID,
		"tags_count", len(tags),
		"tags", tags)

	return tags
}

// NormalizeSubject - –ø—É–±–ª–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ subject
func (p *MessageProcessor) NormalizeSubject(subject string) string {
	return p.normalizeSubject(subject)
}

// FindExistingTaskByThreadEnhanced - –ø—É–±–ª–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è enhanced search
func (p *MessageProcessor) FindExistingTaskByThreadEnhanced(ctx context.Context, email domain.EmailMessage, headers *domain.EmailHeaders) *domain.Task {
	task, _ := p.findExistingTaskByThreadEnhanced(ctx, email, headers)
	return task
}
